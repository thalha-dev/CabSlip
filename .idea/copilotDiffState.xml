<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/dev/thalha/cabslip/ui/components/SignatureCapture.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/dev/thalha/cabslip/ui/components/SignatureCapture.kt" />
              <option name="originalContent" value="package dev.thalha.cabslip.ui.components&#10;&#10;import android.graphics.Bitmap&#10;import android.graphics.Paint&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.border&#10;import androidx.compose.foundation.gestures.detectDragGestures&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.graphics.*&#10;import androidx.compose.ui.graphics.drawscope.DrawScope&#10;import androidx.compose.ui.graphics.drawscope.Stroke&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import kotlinx.coroutines.launch&#10;import java.io.File&#10;import java.io.FileOutputStream&#10;&#10;@Composable&#10;fun SignatureCapture(&#10;    modifier: Modifier = Modifier,&#10;    onSignatureSaved: (String?) -&gt; Unit = {},&#10;    existingSignaturePath: String? = null&#10;) {&#10;    val context = LocalContext.current&#10;    val scope = rememberCoroutineScope()&#10;    val density = LocalDensity.current&#10;&#10;    var paths by remember { mutableStateOf(listOf&lt;Path&gt;()) }&#10;    var currentPath by remember { mutableStateOf(Path()) }&#10;    var hasSignature by remember { mutableStateOf(false) }&#10;    var isDrawing by remember { mutableStateOf(false) }&#10;    var existingSignatureBitmap by remember { mutableStateOf&lt;Bitmap?&gt;(null) }&#10;&#10;    // Load existing signature if available&#10;    LaunchedEffect(existingSignaturePath) {&#10;        if (!existingSignaturePath.isNullOrBlank()) {&#10;            val file = File(existingSignaturePath)&#10;            if (file.exists()) {&#10;                try {&#10;                    val bitmap = android.graphics.BitmapFactory.decodeFile(existingSignaturePath)&#10;                    if (bitmap != null) {&#10;                        existingSignatureBitmap = bitmap&#10;                        hasSignature = true&#10;                    }&#10;                } catch (e: Exception) {&#10;                    existingSignatureBitmap = null&#10;                }&#10;            }&#10;        } else {&#10;            existingSignatureBitmap = null&#10;        }&#10;    }&#10;&#10;    Column(&#10;        modifier = modifier.fillMaxWidth()&#10;    ) {&#10;        Text(&#10;            text = &quot;Owner Signature&quot;,&#10;            fontSize = 16.sp,&#10;            fontWeight = FontWeight.Medium,&#10;            modifier = Modifier.padding(bottom = 8.dp)&#10;        )&#10;&#10;        Card(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .height(200.dp),&#10;            colors = CardDefaults.cardColors(&#10;                containerColor = MaterialTheme.colorScheme.surface&#10;            ),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;        ) {&#10;            Box(&#10;                modifier = Modifier.fillMaxSize()&#10;            ) {&#10;                Canvas(&#10;                    modifier = Modifier&#10;                        .fillMaxSize()&#10;                        .padding(8.dp)&#10;                        .clip(RoundedCornerShape(8.dp))&#10;                        .background(MaterialTheme.colorScheme.surfaceVariant.copy(alpha = 0.3f))&#10;                        .border(&#10;                            1.dp,&#10;                            MaterialTheme.colorScheme.outline.copy(alpha = 0.5f),&#10;                            RoundedCornerShape(8.dp)&#10;                        )&#10;                        .pointerInput(Unit) {&#10;                            detectDragGestures(&#10;                                onDragStart = { offset -&gt;&#10;                                    // Clear existing signature when starting to draw new one&#10;                                    existingSignatureBitmap = null&#10;                                    currentPath = Path().apply {&#10;                                        moveTo(offset.x, offset.y)&#10;                                    }&#10;                                    isDrawing = true&#10;                                },&#10;                                onDragEnd = {&#10;                                    if (isDrawing) {&#10;                                        paths = paths + currentPath&#10;                                        hasSignature = true&#10;                                        isDrawing = false&#10;                                    }&#10;                                }&#10;                            ) { _, dragAmount -&gt;&#10;                                if (isDrawing) {&#10;                                    currentPath.relativeLineTo(dragAmount.x, dragAmount.y)&#10;                                }&#10;                            }&#10;                        }&#10;                ) {&#10;                    // Draw existing signature bitmap if available&#10;                    existingSignatureBitmap?.let { bitmap -&gt;&#10;                        val canvasWidth = size.width&#10;                        val canvasHeight = size.height&#10;&#10;                        val bitmapWidth = bitmap.width.toFloat()&#10;                        val bitmapHeight = bitmap.height.toFloat()&#10;&#10;                        // Scale to fit canvas while maintaining aspect ratio&#10;                        val scale = minOf(canvasWidth / bitmapWidth, canvasHeight / bitmapHeight)&#10;                        val scaledWidth = bitmapWidth * scale&#10;                        val scaledHeight = bitmapHeight * scale&#10;&#10;                        // Center the image&#10;                        val offsetX = (canvasWidth - scaledWidth) / 2&#10;                        val offsetY = (canvasHeight - scaledHeight) / 2&#10;&#10;                        drawImage(&#10;                            image = bitmap.asImageBitmap(),&#10;                            dstOffset = androidx.compose.ui.unit.IntOffset(offsetX.toInt(), offsetY.toInt()),&#10;                            dstSize = androidx.compose.ui.unit.IntSize(scaledWidth.toInt(), scaledHeight.toInt())&#10;                        )&#10;                    }&#10;&#10;                    // Draw completed paths (new signature being drawn)&#10;                    paths.forEach { path -&gt;&#10;                        drawPath(&#10;                            path = path,&#10;                            color = Color.Black,&#10;                            style = Stroke(width = 3.dp.toPx(), cap = StrokeCap.Round)&#10;                        )&#10;                    }&#10;&#10;                    // Draw current path being drawn&#10;                    if (isDrawing) {&#10;                        drawPath(&#10;                            path = currentPath,&#10;                            color = Color.Black,&#10;                            style = Stroke(width = 3.dp.toPx(), cap = StrokeCap.Round)&#10;                        )&#10;                    }&#10;                }&#10;&#10;                if (!hasSignature &amp;&amp; !isDrawing &amp;&amp; existingSignatureBitmap == null) {&#10;                    Box(&#10;                        modifier = Modifier.fillMaxSize(),&#10;                        contentAlignment = Alignment.Center&#10;                    ) {&#10;                        Text(&#10;                            text = &quot;Draw your signature here&quot;,&#10;                            color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                            fontSize = 14.sp&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;        ) {&#10;            OutlinedButton(&#10;                onClick = {&#10;                    paths = emptyList()&#10;                    currentPath = Path()&#10;                    hasSignature = false&#10;                    isDrawing = false&#10;                    existingSignatureBitmap = null&#10;                    onSignatureSaved(null)&#10;                },&#10;                modifier = Modifier.weight(1f)&#10;            ) {&#10;                Text(&quot;Clear&quot;)&#10;            }&#10;&#10;            Button(&#10;                onClick = {&#10;                    if (hasSignature) {&#10;                        scope.launch {&#10;                            try {&#10;                                val signaturePath = if (paths.isNotEmpty()) {&#10;                                    // Save new drawn signature&#10;                                    saveSignatureToPng(context, paths, density)&#10;                                } else {&#10;                                    // Keep existing signature&#10;                                    existingSignaturePath&#10;                                }&#10;                                onSignatureSaved(signaturePath)&#10;                            } catch (e: Exception) {&#10;                                onSignatureSaved(null)&#10;                            }&#10;                        }&#10;                    } else {&#10;                        onSignatureSaved(null)&#10;                    }&#10;                },&#10;                enabled = hasSignature,&#10;                modifier = Modifier.weight(1f)&#10;            ) {&#10;                Text(&quot;Save Signature&quot;)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;private suspend fun saveSignatureToPng(&#10;    context: android.content.Context,&#10;    paths: List&lt;Path&gt;,&#10;    density: androidx.compose.ui.unit.Density&#10;): String? {&#10;    return try {&#10;        val width = with(density) { 400.dp.toPx().toInt() }&#10;        val height = with(density) { 200.dp.toPx().toInt() }&#10;&#10;        val bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888)&#10;        val canvas = android.graphics.Canvas(bitmap)&#10;&#10;        // Fill with white background&#10;        canvas.drawColor(android.graphics.Color.WHITE)&#10;&#10;        val paint = android.graphics.Paint().apply {&#10;            color = android.graphics.Color.BLACK&#10;            strokeWidth = with(density) { 3.dp.toPx() }&#10;            style = android.graphics.Paint.Style.STROKE&#10;            strokeCap = android.graphics.Paint.Cap.ROUND&#10;            isAntiAlias = true&#10;        }&#10;&#10;        // Convert Compose paths to Android paths and draw&#10;        paths.forEach { composePath -&gt;&#10;            val androidPath = composePath.asAndroidPath()&#10;            canvas.drawPath(androidPath, paint)&#10;        }&#10;&#10;        // Save to internal storage&#10;        val signatureDir = File(context.filesDir, &quot;signatures&quot;)&#10;        if (!signatureDir.exists()) {&#10;            signatureDir.mkdirs()&#10;        }&#10;&#10;        val timestamp = System.currentTimeMillis()&#10;        val signatureFile = File(signatureDir, &quot;signature_$timestamp.png&quot;)&#10;&#10;        FileOutputStream(signatureFile).use { out -&gt;&#10;            bitmap.compress(Bitmap.CompressFormat.PNG, 100, out)&#10;        }&#10;&#10;        signatureFile.absolutePath&#10;    } catch (e: Exception) {&#10;        null&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package dev.thalha.cabslip.ui.components&#10;&#10;import android.graphics.Bitmap&#10;import android.graphics.Paint&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.border&#10;import androidx.compose.foundation.gestures.detectDragGestures&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.graphics.*&#10;import androidx.compose.ui.graphics.drawscope.DrawScope&#10;import androidx.compose.ui.graphics.drawscope.Stroke&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import kotlinx.coroutines.launch&#10;import java.io.File&#10;import java.io.FileOutputStream&#10;&#10;@Composable&#10;fun SignatureCapture(&#10;    modifier: Modifier = Modifier,&#10;    onSignatureSaved: (String?) -&gt; Unit = {},&#10;    existingSignaturePath: String? = null&#10;) {&#10;    val context = LocalContext.current&#10;    val scope = rememberCoroutineScope()&#10;    val density = LocalDensity.current&#10;&#10;    var paths by remember { mutableStateOf(listOf&lt;Path&gt;()) }&#10;    var currentPath by remember { mutableStateOf(Path()) }&#10;    var currentPosition by remember { mutableStateOf(Offset.Zero) }&#10;    var hasSignature by remember { mutableStateOf(false) }&#10;    var isDrawing by remember { mutableStateOf(false) }&#10;    var existingSignatureBitmap by remember { mutableStateOf&lt;Bitmap?&gt;(null) }&#10;&#10;    // Load existing signature if available&#10;    LaunchedEffect(existingSignaturePath) {&#10;        if (!existingSignaturePath.isNullOrBlank()) {&#10;            val file = File(existingSignaturePath)&#10;            if (file.exists()) {&#10;                try {&#10;                    val bitmap = android.graphics.BitmapFactory.decodeFile(existingSignaturePath)&#10;                    if (bitmap != null) {&#10;                        existingSignatureBitmap = bitmap&#10;                        hasSignature = true&#10;                    }&#10;                } catch (e: Exception) {&#10;                    existingSignatureBitmap = null&#10;                }&#10;            }&#10;        } else {&#10;            existingSignatureBitmap = null&#10;        }&#10;    }&#10;&#10;    Column(&#10;        modifier = modifier.fillMaxWidth()&#10;    ) {&#10;        Text(&#10;            text = &quot;Owner Signature&quot;,&#10;            fontSize = 16.sp,&#10;            fontWeight = FontWeight.Medium,&#10;            modifier = Modifier.padding(bottom = 8.dp)&#10;        )&#10;&#10;        Card(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .height(200.dp),&#10;            colors = CardDefaults.cardColors(&#10;                containerColor = MaterialTheme.colorScheme.surface&#10;            ),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;        ) {&#10;            Box(&#10;                modifier = Modifier.fillMaxSize()&#10;            ) {&#10;                Canvas(&#10;                    modifier = Modifier&#10;                        .fillMaxSize()&#10;                        .padding(8.dp)&#10;                        .clip(RoundedCornerShape(8.dp))&#10;                        .background(MaterialTheme.colorScheme.surfaceVariant.copy(alpha = 0.3f))&#10;                        .border(&#10;                            1.dp,&#10;                            MaterialTheme.colorScheme.outline.copy(alpha = 0.5f),&#10;                            RoundedCornerShape(8.dp)&#10;                        )&#10;                        .pointerInput(Unit) {&#10;                            detectDragGestures(&#10;                                onDragStart = { offset -&gt;&#10;                                    // Clear existing signature when starting to draw new one&#10;                                    existingSignatureBitmap = null&#10;                                    currentPath = Path().apply {&#10;                                        moveTo(offset.x, offset.y)&#10;                                    }&#10;                                    currentPosition = offset&#10;                                    isDrawing = true&#10;                                },&#10;                                onDragEnd = {&#10;                                    if (isDrawing) {&#10;                                        paths = paths + currentPath&#10;                                        hasSignature = true&#10;                                        isDrawing = false&#10;                                        currentPath = Path() // Reset current path&#10;                                    }&#10;                                }&#10;                            ) { _, dragAmount -&gt;&#10;                                if (isDrawing) {&#10;                                    currentPosition = Offset(&#10;                                        currentPosition.x + dragAmount.x,&#10;                                        currentPosition.y + dragAmount.y&#10;                                    )&#10;                                    currentPath.lineTo(currentPosition.x, currentPosition.y)&#10;                                }&#10;                            }&#10;                        }&#10;                ) {&#10;                    // Draw existing signature bitmap if available&#10;                    existingSignatureBitmap?.let { bitmap -&gt;&#10;                        val canvasWidth = size.width&#10;                        val canvasHeight = size.height&#10;&#10;                        val bitmapWidth = bitmap.width.toFloat()&#10;                        val bitmapHeight = bitmap.height.toFloat()&#10;&#10;                        // Scale to fit canvas while maintaining aspect ratio&#10;                        val scale = minOf(canvasWidth / bitmapWidth, canvasHeight / bitmapHeight)&#10;                        val scaledWidth = bitmapWidth * scale&#10;                        val scaledHeight = bitmapHeight * scale&#10;&#10;                        // Center the image&#10;                        val offsetX = (canvasWidth - scaledWidth) / 2&#10;                        val offsetY = (canvasHeight - scaledHeight) / 2&#10;&#10;                        drawImage(&#10;                            image = bitmap.asImageBitmap(),&#10;                            dstOffset = androidx.compose.ui.unit.IntOffset(offsetX.toInt(), offsetY.toInt()),&#10;                            dstSize = androidx.compose.ui.unit.IntSize(scaledWidth.toInt(), scaledHeight.toInt())&#10;                        )&#10;                    }&#10;&#10;                    // Draw completed paths (new signature being drawn)&#10;                    paths.forEach { path -&gt;&#10;                        drawPath(&#10;                            path = path,&#10;                            color = Color.Black,&#10;                            style = Stroke(width = 3.dp.toPx(), cap = StrokeCap.Round)&#10;                        )&#10;                    }&#10;&#10;                    // Draw current path being drawn - this will now update in real-time&#10;                    if (isDrawing &amp;&amp; !currentPath.isEmpty) {&#10;                        drawPath(&#10;                            path = currentPath,&#10;                            color = Color.Black,&#10;                            style = Stroke(width = 3.dp.toPx(), cap = StrokeCap.Round)&#10;                        )&#10;                    }&#10;                }&#10;&#10;                if (!hasSignature &amp;&amp; !isDrawing &amp;&amp; existingSignatureBitmap == null) {&#10;                    Box(&#10;                        modifier = Modifier.fillMaxSize(),&#10;                        contentAlignment = Alignment.Center&#10;                    ) {&#10;                        Text(&#10;                            text = &quot;Draw your signature here&quot;,&#10;                            color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                            fontSize = 14.sp&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;        ) {&#10;            OutlinedButton(&#10;                onClick = {&#10;                    paths = emptyList()&#10;                    currentPath = Path()&#10;                    hasSignature = false&#10;                    isDrawing = false&#10;                    existingSignatureBitmap = null&#10;                    onSignatureSaved(null)&#10;                },&#10;                modifier = Modifier.weight(1f)&#10;            ) {&#10;                Text(&quot;Clear&quot;)&#10;            }&#10;&#10;            Button(&#10;                onClick = {&#10;                    if (hasSignature) {&#10;                        scope.launch {&#10;                            try {&#10;                                val signaturePath = if (paths.isNotEmpty()) {&#10;                                    // Save new drawn signature&#10;                                    saveSignatureToPng(context, paths, density)&#10;                                } else {&#10;                                    // Keep existing signature&#10;                                    existingSignaturePath&#10;                                }&#10;                                onSignatureSaved(signaturePath)&#10;                            } catch (e: Exception) {&#10;                                onSignatureSaved(null)&#10;                            }&#10;                        }&#10;                    } else {&#10;                        onSignatureSaved(null)&#10;                    }&#10;                },&#10;                enabled = hasSignature,&#10;                modifier = Modifier.weight(1f)&#10;            ) {&#10;                Text(&quot;Save Signature&quot;)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;private suspend fun saveSignatureToPng(&#10;    context: android.content.Context,&#10;    paths: List&lt;Path&gt;,&#10;    density: androidx.compose.ui.unit.Density&#10;): String? {&#10;    return try {&#10;        val width = with(density) { 400.dp.toPx().toInt() }&#10;        val height = with(density) { 200.dp.toPx().toInt() }&#10;&#10;        val bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888)&#10;        val canvas = android.graphics.Canvas(bitmap)&#10;&#10;        // Fill with white background&#10;        canvas.drawColor(android.graphics.Color.WHITE)&#10;&#10;        val paint = android.graphics.Paint().apply {&#10;            color = android.graphics.Color.BLACK&#10;            strokeWidth = with(density) { 3.dp.toPx() }&#10;            style = android.graphics.Paint.Style.STROKE&#10;            strokeCap = android.graphics.Paint.Cap.ROUND&#10;            isAntiAlias = true&#10;        }&#10;&#10;        // Convert Compose paths to Android paths and draw&#10;        paths.forEach { composePath -&gt;&#10;            val androidPath = composePath.asAndroidPath()&#10;            canvas.drawPath(androidPath, paint)&#10;        }&#10;&#10;        // Save to internal storage&#10;        val signatureDir = File(context.filesDir, &quot;signatures&quot;)&#10;        if (!signatureDir.exists()) {&#10;            signatureDir.mkdirs()&#10;        }&#10;&#10;        val timestamp = System.currentTimeMillis()&#10;        val signatureFile = File(signatureDir, &quot;signature_$timestamp.png&quot;)&#10;&#10;        FileOutputStream(signatureFile).use { out -&gt;&#10;            bitmap.compress(Bitmap.CompressFormat.PNG, 100, out)&#10;        }&#10;&#10;        signatureFile.absolutePath&#10;    } catch (e: Exception) {&#10;        null&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>